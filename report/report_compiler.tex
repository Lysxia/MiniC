\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{pgf}
\usepackage{tikz}

\begin{document}

\title{Compilateur MiniC}
\author{Li-yao Xia}
\date{\today}

\maketitle
%\normalsize

\section{Commentaires généraux}

Comme je ne savais pas par où commencer,
j'ai choisi d'écrire le compilateur dans l'ordre
des différentes étapes de l'analyse. 

Lexeur -> Parseur -> Typeur

Les fichiers qui composent mon programme sont :
\begin{itemize}
  \item {\it lexer.mll}
  \item {\it ast.mli} - Décrit le type d'arbre de syntaxe
  abstraite décoré en sortie du parseur.
  \item {\it parser.mly}
  \item {\it error.ml} - Fichier commun à tout le programme,
  de gestion d'erreurs (affichage des messages d'erreur)
  \item {\it typing.ml/.mli}
  \item {\it main.ml}
\end{itemize}

(Il y a un fichier {\it parser\_test.ml} mais il ne fait pas
partie du programme final)

\section{Choix et difficultés}

Je m'y suis pris assez tôt, donc j'avais globalement fini le
lexeur et le parseur avant qu'ils ne soient abordés dans le cours.

En cas d'ambiguïté dans le sujet, gcc a été la référence. (ainsi que pour
les messages d'erreurs que j'ai repris)

Pour la deuxième partie du sujet j'ai décidé d'utiliser la sélection
d'instructions.

J'ai d'abord modifié le typeur et l'AST :
\begin{itemize}
  \item les fonctions sont représentées par un type enregistrement,
  pour plus de lisibilité
  \item les variables globales et locales sont gérées différemment par le
  typeur, en particulier seules les variables locales sont converties en
  entiers.
  \item les variables locales sont ramenées en en-tête des fonctions
\end{itemize}


\end{document}


